# 读《The Implementation of Lua 5.0》

#### 一、Lua的设计和实现总览

1. 简洁
2. 高效
3. 可移植
4. 可嵌入
5. 容易嵌入

Lua早期版本使用的是手工编写的词法分析器，和手工编写的递归下降语法分析器。直到Lua3.0之后开始使用YACC自动生成的语法分析器。



#### 二、Lua值的内部表示

##### 总览：

Lua具有8种基本的值类型：nil，boolean，number，string，table，function，userdata和thread。

所有的类型都是第一类值：即可以存入全局变量、局部变量或table中，或作为实际参数传递给函数，或从函数中返回值。

Lua将值表示成带标志的联合结构，即(t, v)对，其中t为整数，代表v的类型，v是C语言的一个union类型数据结构，储存有实际的值。

Value中n用于表示number（默认情况下，lua_Number被定义为double类型），b用于boolean，p用于light userdata，gc用于需要垃圾回收机制处理的其他值（string，table，function，heavy userdata，threads）。

#### 三、表：

在Lua5.0中，表会维护一个散列表部分和一个数组部分，如果键值是整数表项时，将不保存键。

数组部分将试图保存那些键值介于1到某个上限n之间的值，非整数部分和超过数组范围n的整数键对应的值将被存入到散列表中。

当表需要增长时，Lua会重新计算散列表部分和数组部分的大小。最初表的两个部分可能都是空的。新的数组部分的大小时满足以下条件的最大的n值：1到n之间至少一半的空间会被利用；且n/2+1到n之间的空间至少有一个空间被利用。当新的大小计算出来后，Lua为数组重新申请空间，并将原来的数据存入新的空间。

#### 这种混合结构有两个有优点。第一，存取整数的值很快，因为无需计算散列值。第二，相比将数据存入散列部分，数组大概只需要相对散列一半的空间，因为在数组部分，键是隐含的。

#### 四、函数与闭包：

Lua用一种成为upvalue的结构来实现闭包。对任何外层局部变量的存取间接通过upvalue来进行。upvalue最初指向栈中变量活跃的地方。当离开变量作用域的时候（超过变量生存期），变量被复制到upvalue中。

Lua针对每个变量，至少创建一个upvalue并按情况进行重复利用。Lua为整个运行栈保存了一个链表将所有upvalue都存起来。当一个新的闭包创建的时候，会先去遍历这个链表查看是不是有相对应的upvalue，若存在则直接使用，若不存在则创建一个新的upvalue并加入链表。当这个upvalue关闭后则从链表中删除，当所有闭包都不使用这个upvalue时，那它的储存空间则马上被释放。

一个闭包可能存取其更外层的函数而非直接外层函数的直接变量。这种情况下，有可能当闭包创建时，此局部变量尚不存在。Lua使用flat闭包来处理这种情况。有了flat闭包，无论何时只要函数存取更外层的局部变量，该变量也会进入其直接外层函数的闭包中。这样当一个函数被实例化时，所有进入其闭包的变量就在直接外层函数的栈或者闭包中了。

#### 五、线程和协程：

#### 六、虚拟机：

Lua解析器在执行Lua程序时，首先将源码编译成虚拟机指令（opcode）然后再执行对应的函数。对每个被编译的函数，Lua为其创建一个原型，原型中含有一个由该函数的虚拟机指令组成的数组、一个所有被该函数用到的常量数组（避免opcode中直接包含常量导致指令长度膨胀）。

在之前的Lua版本中，Lua采用的是基于堆栈的虚拟机，在Lua5.0后，Lua改用基于寄存器的虚拟机。基于寄存器的虚拟机也采用到了栈分配活动记录，寄存器就在这些活动记录中。当Lua程序进入函数体时，它会从栈中预分配一个足以容纳所有函数寄存器的活动记录。所有局部变量都存在寄存器中，所以访问局部变量是非常高效的。

使用寄存式虚拟机时消除了用堆栈式虚拟机为了在栈中拷贝数据而需要的大量出入栈指令(push/pop)。

Lua的虚拟机指令将32位分为3个或者4个区域，OP为指令区域，占6位。其他域是操作数。A域是总是存在的，占8位。B、C域各占9位。它们可以组成一个18位的Bx域（无符号）或sBx（有符号）。

大部分指令使用三地址格式，其中A代表目的寄存器；B、C分别表示源操作数，可能是寄存器或常数。

